<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CaratheodoryFejerApprox.jl</title><meta name="title" content="Home · CaratheodoryFejerApprox.jl"/><meta property="og:title" content="Home · CaratheodoryFejerApprox.jl"/><meta property="twitter:title" content="Home · CaratheodoryFejerApprox.jl"/><meta name="description" content="Documentation for CaratheodoryFejerApprox.jl."/><meta property="og:description" content="Documentation for CaratheodoryFejerApprox.jl."/><meta property="twitter:description" content="Documentation for CaratheodoryFejerApprox.jl."/><meta property="og:url" content="https://jondeuce.github.io/CaratheodoryFejerApprox.jl/"/><meta property="twitter:url" content="https://jondeuce.github.io/CaratheodoryFejerApprox.jl/"/><link rel="canonical" href="https://jondeuce.github.io/CaratheodoryFejerApprox.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CaratheodoryFejerApprox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#docstrings"><span>Docstrings</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CaratheodoryFejerApprox.jl"><a class="docs-heading-anchor" href="#CaratheodoryFejerApprox.jl">CaratheodoryFejerApprox.jl</a><a id="CaratheodoryFejerApprox.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CaratheodoryFejerApprox.jl" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl">CaratheodoryFejerApprox.jl</a>.</p><h2 id="docstrings"><a class="docs-heading-anchor" href="#docstrings">Docstrings</a><a id="docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#docstrings" title="Permalink"></a></h2><ul><li><a href="#CaratheodoryFejerApprox.CaratheodoryFejerApprox"><code>CaratheodoryFejerApprox.CaratheodoryFejerApprox</code></a></li><li><a href="#CaratheodoryFejerApprox.RationalApproximant"><code>CaratheodoryFejerApprox.RationalApproximant</code></a></li><li><a href="#CaratheodoryFejerApprox.chebcoeffs"><code>CaratheodoryFejerApprox.chebcoeffs</code></a></li><li><a href="#CaratheodoryFejerApprox.minimax"><code>CaratheodoryFejerApprox.minimax</code></a></li><li><a href="#CaratheodoryFejerApprox.monocoeffs"><code>CaratheodoryFejerApprox.monocoeffs</code></a></li><li><a href="#CaratheodoryFejerApprox.polynomialcf"><code>CaratheodoryFejerApprox.polynomialcf</code></a></li><li><a href="#CaratheodoryFejerApprox.rationalcf"><code>CaratheodoryFejerApprox.rationalcf</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CaratheodoryFejerApprox.CaratheodoryFejerApprox" href="#CaratheodoryFejerApprox.CaratheodoryFejerApprox"><code>CaratheodoryFejerApprox.CaratheodoryFejerApprox</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>CaratheodoryFejerApprox.jl</strong></p><p><a href="https://jondeuce.github.io/CaratheodoryFejerApprox.jl/dev/"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/actions/workflows/CI.yml?query=branch%3Amaster"><img src="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/actions/workflows/CI.yml/badge.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/gh/jondeuce/CaratheodoryFejerApprox.jl"><img src="https://codecov.io/gh/jondeuce/CaratheodoryFejerApprox.jl/branch/master/graph/badge.svg" alt="Coverage"/></a> <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg" alt="Aqua QA"/></a></p><p><strong>Introduction</strong></p><p><code>CaratheodoryFejerApprox.jl</code> offers robust near-minimax approximation of arbitrary smooth functions using the <a href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/tree/master#References">Carathéodory-Fejér method</a>. This method approximates real functions with polynomials or rationals by transplanting the problem onto the unit disk in the complex plane, applying the Carathéodory-Fejér theorem, and constructing a near-best approximation from the eigenvalues and eigenvectors of a Hankel matrix containing coefficients from the Chebyshev series expansion of the function.</p><p>Much of the functionality in <code>CaratheodoryFejerApprox.jl</code> began as a translation of Matlab code from the fantastic <a href="https://github.com/chebfun/chebfun/tree/master"><code>Chebfun</code></a> package, specifically <a href="https://github.com/chebfun/chebfun/blob/master/%40chebfun/cf.m"><code>chebfun/@chebfun/cf.m</code></a>. Additionally, internally we make heavy use of the analagous Julia package <a href="https://github.com/JuliaApproximation/ApproxFun.jl"><code>ApproxFun.jl</code></a>.</p><p><strong>Package Features</strong></p><p><strong>Polynomial Approximation</strong></p><pre><code class="language-julia hljs">polynomialcf(f, m::Int) -&gt; RationalApproximant{Float64}
polynomialcf(f, dom::NTuple{2, T}, m::Int) -&gt; RationalApproximant{T}</code></pre><p>Approximate a function <code>f</code> with a degree <code>m</code> polynomial CF approximant on the interval <code>dom</code>. If not specified, <code>dom</code> defaults to <code>(-1.0, 1.0)</code>.</p><p><strong>Rational Approximation</strong></p><pre><code class="language-julia hljs">rationalcf(f, m::Int, n::Int) -&gt; RationalApproximant{Float64}
rationalcf(f, dom::NTuple{2, T}, m::Int, n::Int) -&gt; RationalApproximant{T}</code></pre><p>Approximate a function <code>f</code> with a type <code>(m, n)</code> rational CF approximant on the interval <code>dom</code>, where <code>m</code> is the numerator degree and <code>n</code> is the denominator degree. If not specified, <code>dom</code> defaults to <code>(-1.0, 1.0)</code>.</p><p><strong>Minimax Fine-Tuning</strong></p><pre><code class="language-julia hljs">minimax(f, m::Int, n::Int) -&gt; RationalApproximant{Float64}
minimax(f, dom::NTuple{2, T}, m::Int, n::Int) -&gt; RationalApproximant{T}</code></pre><p>Compute the type <code>(m, n)</code> CF approximant and then, if necessary, fine-tune the approximant to become a true minimax approximant using the <a href="https://en.wikipedia.org/wiki/Remez_algorithm">Remez algorithm</a>. If not specified, <code>dom</code> defaults to <code>(-1.0, 1.0)</code>.</p><p><strong>Polynomial Coefficient Basis</strong></p><pre><code class="language-julia hljs">chebcoeffs(res::RationalApproximant{T}) -&gt; NTuple{2, Vector{T}}
monocoeffs(res::RationalApproximant{T}; transplant = true) -&gt; NTuple{2, Vector{T}}
monocoeffs(res::RationalApproximant{T1}, ::Type{T2} = BigFloat; transplant = true) -&gt; NTuple{2, Vector{T1}}</code></pre><p>Extract polynomial coefficients in the monomial basis via <code>monocoeffs(res)</code> or in the Chebyshev basis via <code>chebcoeffs(res)</code>. As converting to monomial coefficients can be numerically unstable, optionally pass a higher precision type to <code>monocoeffs</code> for intermediate computations.</p><p>When <code>transplant = true</code> (the default), the monomial coefficients correspond to the original function <code>f(x)</code> on the interval <code>dom</code>. If <code>transplant = false</code>, they correspond to the linearly transplanted function <code>g(t) = f((x - mid) / rad)</code> where <code>mid</code> and <code>rad</code> are the midpoint and radius of <code>dom</code> and <code>-1 &lt;= t &lt;= 1</code>.</p><p>Note that, particularly when <code>|mid|</code> is large, it can be much more numerically stable to evaluate the approximant via <code>evalpoly(t, p)</code> using the non-transplanted coefficients <code>p</code> and <code>t = (x - mid) / rad</code>.</p><p>The Chebyshev coefficients always correspond to the linearly transplanted function <code>g(t) = f((x - mid) / rad)</code> used internally; they are not transplanted to <code>dom</code>.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">julia&gt; using CaratheodoryFejerApprox </code></pre><p><strong>Polynomial approximant</strong></p><p>Compute a degree 5 polynomial CF approximant to <code>cos(x)</code> on the interval <code>[-0.5, 0.5]</code>:</p><pre><code class="language-julia hljs">julia&gt; res = polynomialcf(cos, (-0.5, 0.5), 5) 
RationalApproximant{Float64}
  Type:   m / n = 4 / 0
  Domain: -0.5 ≤ x ≤ 0.5
  Error:  |f - p| ⪅ 6.721e-7
  Approximant:
      p(t) = 0.9385⋅T_0(t) - 0.06121⋅T_2(t) + 0.0003215⋅T_4(t)
  where: t = (x - 0.0) / 0.5</code></pre><p>A few things to note:</p><ul><li>While we requested a degree 5 approximant, <code>polynomialcf</code> automatically recognized that <code>cos(x)</code> is an even function and therefore truncated the approximant to degree 4</li><li>The polynomial approximant is displayed in the Chebyshev basis, transplanted to the standard interval <code>[-1, 1]</code>. In this case, we see that <code>cos(x) ≈ p(t)</code> where <code>t = 2x</code></li><li>Despite being low degree the approximant is quite accurate, with an estimated 6-7 digits of worst-case accuracy</li></ul><p>Next, let&#39;s extract the coefficients of the rational approximant in the monomial basis:</p><pre><code class="language-julia hljs">julia&gt; p, q = monocoeffs(res) 
([0.9999993278622336, 0.0, -0.49995153387633173, 0.0, 0.04114863415981116], [1.0])</code></pre><p>The resulting monomial coefficients are close to (but not equal to) the Taylor expansion of <code>cos(x)</code> at the origin: <code>cos(x) = 1 - x^2/2 + x^4/24 + O(x^6) ≈ 1.0 - 0.5 x^2 + 0.04166 x^4</code>. This is a common feature of minimax approximants; they are often similar to Taylor series expansions, but adjusted to tradeoff accuracy near the Taylor expansion point for accuracy over the whole interval.</p><p><strong>Rational approximant</strong></p><p>We can simlarly compute a type <code>(4, 4)</code> rational approximant to <code>exp(x)</code> on <code>[-1, 1]</code> as follows:</p><pre><code class="language-julia hljs">julia&gt; res = rationalcf(exp, 4, 4) 
RationalApproximant{Float64}
  Type:   m / n = 4 / 4
  Domain: -1.0 ≤ x ≤ 1.0
  Error:  |f - p / q| ⪅ 1.538e-10
  Approximant:
      p(x) = 1.054⋅T_0(x) + 0.511⋅T_1(x) + 0.05434⋅T_2(x) + 0.003018⋅T_3(x) + 7.582e-5⋅T_4(x)
      q(x) = 1.053⋅T_0(x) - 0.5068⋅T_1(x) + 0.05333⋅T_2(x) - 0.002919⋅T_3(x) + 7.173e-5⋅T_4(x)</code></pre><p>Note again the low error - approximately 10 digits of accuracy - despite the small degrees of the numerator and denominator.</p><p><strong>Minimax approximant</strong></p><p>Now compare the type <code>(4, 4)</code> CF approximant with the corresponding type <code>(4, 4)</code> minimax approximant:</p><pre><code class="language-julia hljs">julia&gt; res = minimax(exp, 4, 4) 
RationalApproximant{Float64}
  Type:   m / n = 4 / 4
  Domain: -1.0 ≤ x ≤ 1.0
  Error:  |f - p / q| ⪅ 1.538e-10
  Approximant:
      p(x) = 1.054⋅T_0(x) + 0.511⋅T_1(x) + 0.05434⋅T_2(x) + 0.003018⋅T_3(x) + 7.582e-5⋅T_4(x)
      q(x) = 1.053⋅T_0(x) - 0.5068⋅T_1(x) + 0.05333⋅T_2(x) - 0.002919⋅T_3(x) + 7.173e-5⋅T_4(x)</code></pre><p>We see that the coefficients are identical, and in fact the error bound is sharp over the whole interval. This is the magic of CF approximants: they are often <em>very nearly</em> true minimax approximants.</p><p><strong>High-precision rational approximant</strong></p><p>Care has been taken to ensure all internal computations work for generic float types, so we can easily compute a high degree minimax approximant in arbitrary precision:</p><pre><code class="language-julia hljs">julia&gt; res = minimax(sin, BigFloat.((-1, 1)), 20, 16) 
RationalApproximant{BigFloat}
  Type:   m / n = 19 / 16
  Domain: -1.0 ≤ x ≤ 1.0
  Error:  |f - p / q| ⪅ 8.282e-56
  Approximant:
      p(x) = 0.8859⋅T_1(x) - 0.03733⋅T_3(x) + 0.0004165⋅T_5(x) - 1.997e-6⋅T_7(x) + 4.995e-9⋅T_9(x) - 7.17e-12⋅T_11(x) + 6.155e-15⋅T_13(x) - 3.147e-18⋅T_15(x) + 8.94e-22⋅T_17(x) - 1.102e-25⋅T_19(x)
      q(x) = 1.004⋅T_0(x) + 0.00447⋅T_2(x) + 4.94e-6⋅T_4(x) + 3.57e-9⋅T_6(x) + 1.861e-12⋅T_8(x) + 7.234e-16⋅T_10(x) + 2.072e-19⋅T_12(x) + 4.0509999999999997e-23⋅T_14(x) + 4.201e-27⋅T_16(x)</code></pre><p>Here we have computed a type <code>(20, 16)</code> minimax approximation to <code>sin(x)</code> on <code>[-1, 1]</code> accurate to about 55 digits. Note again that internally <code>sin(x)</code> was recognized to be an odd function of <code>x</code>, and therefore the numerator degree was truncated from 20 to 19.</p><p><strong>Application: implementing the modified Bessel function of the first kind of order zero</strong></p><p>To show how minimax approximants may be used in practice, let&#39;s derive polynomial approximants for the modified Bessel function of the first kind of order zero <code>I₀(x)</code> using <code>polynomialcf</code>. We&#39;ll compare the approximants to those provided by the <a href="https://github.com/JuliaMath/Bessels.jl/blob/e69f0030d6b4f7a73880d693560378e2aec7295c/src/BesselFunctions/besseli.jl#L60"><code>Bessels.jl</code> package</a>.</p><p>Following <code>Bessels.jl</code>, we&#39;ll use the following piecewise approximant for <code>I₀(x)</code>:</p><ul><li>For <code>x &lt; 7.75</code> we let <code>I₀(x) = 1 + (x/2)^2 P₁((x/2)^2)</code></li><li>For <code>x ≥ 7.75</code> we let <code>I₀(x) = exp(x) P₂(1/x) / sqrt(x)</code></li></ul><p>where <code>P₁</code> and <code>P₂</code> are polynomial approximants. Note that <code>I₀(x)</code> is an even function, so we need only consider positive <code>x</code>.</p><p>First, we need the true <code>I₀(x)</code>. We will compute this via the integral representation <code>I₀(x) = (1 / π) ∫_0^π exp(x cos(t)) dt</code>, which can be evaluated precisely using <code>QuadGK.jl</code> with <code>BigFloat</code>s:</p><pre><code class="language-julia hljs">julia&gt; using QuadGK, Bessels 

julia&gt; function besseli0_quadgk(x::BigFloat; expscale = false) 
           I, E = quadgk(BigFloat(0.0), BigFloat(π); order = 21, rtol = 1e-50) do t
               # I₀(x) diverges exponentially for large x; optionally compute exp(-x) I₀(x) instead
               return expscale ? exp(x * (cos(t) - 1)) : exp(x * cos(t))
           end
           return I / π
       end; 

julia&gt; besseli0_quadgk(x; kwargs...) = oftype(x, besseli0_quadgk(BigFloat(x); kwargs...)); </code></pre><p>Let&#39;s first check that this matches <code>Bessels.jl</code>s implementation:</p><pre><code class="language-julia hljs">julia&gt; @assert Bessels.besseli0(0.5) ≈ besseli0_quadgk(0.5; expscale = false) 

julia&gt; @assert Bessels.besseli0x(100.0) ≈ besseli0_quadgk(100.0; expscale = true) </code></pre><p>Now, we use <code>polynomialcf</code> to compute the polynomial <code>P₁</code> for <code>x &lt; 7.75</code>:</p><pre><code class="language-julia hljs"># We are aiming to find P₁(t) such that I₀(x) = 1 + (x/2)^2 P₁((x/2)^2)
julia&gt; xdom = Double64.((0.0, 7.75)); # compute coefficients in higher precision 

julia&gt; tdom = (xdom ./ 2) .^ 2; # t = (x/2)^2 

julia&gt; res = polynomialcf(tdom, 13) do t 
           x = 2√t
           I₀ = besseli0_quadgk(x; expscale = false)
           return t == 0 ? one(t) : (I₀ - 1) / t # P₁(t) = (I₀(x) - 1) / (x/2)^2 = (I₀(x) - 1) / t
       end 
RationalApproximant{Double64}
  Type:   m / n = 13 / 0
  Domain: 0.0 ≤ x ≤ 15.02
  Error:  |f - p| ⪅ 2.0e-16
  Approximant:
      p(t) = 8.518⋅T_0(t) + 10.13⋅T_1(t) + 3.143⋅T_2(t) + 0.5982⋅T_3(t) + 0.0769⋅T_4(t) + 0.007112⋅T_5(t) + 0.0004954⋅T_6(t) + 2.689e-5⋅T_7(t) + 1.169e-6⋅T_8(t) + 4.158e-8⋅T_9(t) + 1.232e-9⋅T_10(t) + 3.087e-11⋅T_11(t) + 6.625e-13⋅T_12(t) + 1.231e-14⋅T_13(t)
  where: t = (x - 7.508) / 7.508</code></pre><p>We see that the approximant is accurate to about <code>eps(Float64)</code> over the interval. Now, let&#39;s compare these coefficients to those from <code>Bessels.jl</code>:</p><pre><code class="language-julia hljs">julia&gt; const P₁_vec = monocoeffs(res)[1] .|&gt; Float64; # coefficients for P₁(t) 

julia&gt; const P₁_tup = (P₁_vec...,); # `evalpoly` is faster with tuples of coefficients 

julia&gt; maximum(abs, (P₁_tup .- Bessels.besseli0_small_coefs(Float64)) ./ P₁_tup) # maximum relative difference 
0.0</code></pre><p>Our derived coefficients are identical. Similarly, let&#39;s now use <code>polynomialcf</code> to compute the polynomial approximant <code>P₂(t)</code> for <code>x ≥ 7.75</code>:</p><pre><code class="language-julia hljs"># We are aiming to find P₂(t) such that I₀(x) = exp(x) P₂(1/x) / sqrt(x)`
julia&gt; tdom = Double64.((1 / 1e6, 1 / 7.75)); # t = 1/x; domain bounds copied from `Bessels.jl` 

julia&gt; res = polynomialcf(tdom, 21) do t 
           x = inv(t)
           I₀ₓ = besseli0_quadgk(x; expscale = true) # exp(-x) * I₀(x)
           return √x * I₀ₓ # P₂(t) = √x * exp(-x) * I₀(x)
       end 
RationalApproximant{Double64}
  Type:   m / n = 21 / 0
  Domain: 1.0e-6 ≤ x ≤ 0.129
  Error:  |f - p| ⪅ 6.292e-17
  Approximant:
      p(t) = 0.4024⋅T_0(t) + 0.003488⋅T_1(t) + 7.408e-5⋅T_2(t) + 3.25e-6⋅T_3(t) + 2.43e-7⋅T_4(t) + 2.837e-8⋅T_5(t) + 4.332e-9⋅T_6(t) + 5.778e-10⋅T_7(t) - 2.278e-11⋅T_8(t) - 5.335e-11⋅T_9(t) - 1.818e-11⋅T_10(t) - 1.24e-12⋅T_11(t) + 1.425e-12⋅T_12(t) + 5.084e-13⋅T_13(t) - 4.223e-14⋅T_14(t) - 6.879e-14⋅T_15(t) - 6.505e-15⋅T_16(t) + 8.044e-15⋅T_17(t) + 1.82e-15⋅T_18(t) - 9.757e-16⋅T_19(t) - 3.463e-16⋅T_20(t) + 1.191e-16⋅T_21(t)
  where: t = (x - 0.06452) / 0.06452</code></pre><p>The approximant is again accurate to about <code>eps(Float64)</code> over the interval. Let&#39;s again compare these coefficients to those from <code>Bessels.jl</code>:</p><pre><code class="language-julia hljs">julia&gt; const P₂_vec = monocoeffs(res)[1] .|&gt; Float64; # coefficients for P₂(t) 

julia&gt; const P₂_tup = (P₂_vec...,); # `evalpoly` is faster with tuples of coefficients 

julia&gt; maximum(abs, (P₂_tup .- Bessels.besseli0_med_coefs(Float64)) ./ P₂_tup) # maximum relative difference 
1.1172124075993363e-15</code></pre><p>Again, we see that the derived coefficients are in good agreement.</p><p>Finally, we can now define our implementation of <code>I₀(x)</code> using the approximants <code>P₁</code> and <code>P₂</code>. Modifying the code from <a href="https://github.com/JuliaMath/Bessels.jl/blob/e69f0030d6b4f7a73880d693560378e2aec7295c/src/BesselFunctions/besseli.jl#L60"><code>Bessels.jl</code></a>, we have:</p><pre><code class="language-julia hljs">julia&gt; function besseli0_cf(x::Float64) 
           x = abs(x)
           if x &lt; 7.75
               a = x * x / 4
               return muladd(a, evalpoly(a, P₁_tup), 1)
           else
               a = exp(x / 2)
               s = a * evalpoly(inv(x), P₂_tup) / sqrt(x)
               return a * s
           end
       end; 

julia&gt; @assert Bessels.besseli0(0.5) ≈ besseli0_cf(0.5) 

julia&gt; @assert Bessels.besseli0(100.0) ≈ besseli0_cf(100.0) </code></pre><p><strong>References</strong></p><p><strong>[1] Real Polynomial Chebyshev Approximation by the Carathéodory-Fejér Method <a href="https://epubs.siam.org/doi/abs/10.1137/0719022">(Gutknecht and Trefethen, 1982)</a></strong></p><p>This foundational work introduces a novel method for near-best approximation of real functions by polynomials. The approach involves transforming the problem onto the unit disk and applying the Carathéodory-Fejér theorem. The resulting approximation is constructed from the principal eigenvalue and eigenvector of a Hankel matrix of Chebyshev coefficients. The method offers high-order agreement with the best approximation, making it of both practical and theoretical importance. This package implements this work in <code>polynomialcf</code>.</p><p><strong>[2] The Carathéodory-Fejér Method for Real Rational Approximation <a href="https://epubs.siam.org/doi/abs/10.1137/0720030">(Trefethen and Gutknecht, 1983)</a></strong></p><p>This work extends the Carathéodory-Fejér method for polynomial minimax approximants to real rational approximation, similarly leveraging eigenvalue analysis of a Hankel matrix of Chebyshev coefficients to achieve this. The rational CF approximants frequently approach the best rational approximation with high accuracy. This package implements this work in <code>rationalcf</code>.</p><p><strong>[3] A Robust Implementation of the Carathéodory-Fejér Method for Rational Approximation <a href="https://doi.org/10.1007/s10543-011-0331-7">(Van Deun and Trefethen, 2011)</a></strong></p><p>This work details a robust implementation of the Carathéodory-Fejér method for both polynomial and rational approximation in Matlab within the Chebfun package ecosystem. <code>CaratheodoryFejerApprox.jl</code> is based largely on this reference implementation, providing users with a powerful tool for rational approximation in Julia which additionally works for generic float types beyond <code>Float64</code>, such as <code>BigFloat</code> and <code>Double64</code>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/blob/ada1293b8ef3328395fd40782a7f984f459dd4ac/src/CaratheodoryFejerApprox.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CaratheodoryFejerApprox.RationalApproximant" href="#CaratheodoryFejerApprox.RationalApproximant"><code>CaratheodoryFejerApprox.RationalApproximant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RationalApproximant{T &lt;: AbstractFloat}</code></pre><p>A simple wrapper type returned by <code>polynomialcf</code>, <code>rationalcf</code>, and <code>minimax</code> representing a rational approximant on an interval. Numerator and denominator coefficients are stored in the Chebyshev basis. Coefficients can be extracted from <code>res::RationalApproximant</code> in the Chebyshev basis via <code>chebcoeffs(res)</code> or in the monomial basis via <code>monocoeffs(res)</code>. For convenience, the approximant is also callable: <code>res(x)</code> evaluates the rational approximant <code>p(x) / q(x)</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/blob/ada1293b8ef3328395fd40782a7f984f459dd4ac/src/CaratheodoryFejerApprox.jl#L119-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CaratheodoryFejerApprox.chebcoeffs" href="#CaratheodoryFejerApprox.chebcoeffs"><code>CaratheodoryFejerApprox.chebcoeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">chebcoeffs(res::RationalApproximant{T}) -&gt; NTuple{2, Vector{T}}</code></pre><p>Extract polynomial coefficients of a <code>RationalApproximant</code> in the Chebyshev basis.</p><p>The Chebyshev coefficients always correspond to the linearly transplanted function <code>g(t) = f((x - mid) / rad)</code> used internally; they are not transplanted to <code>dom</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/blob/ada1293b8ef3328395fd40782a7f984f459dd4ac/src/CaratheodoryFejerApprox.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CaratheodoryFejerApprox.minimax" href="#CaratheodoryFejerApprox.minimax"><code>CaratheodoryFejerApprox.minimax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimax(f, m::Int, n::Int) -&gt; RationalApproximant{Float64}
minimax(f, dom::NTuple{2, T}, m::Int, n::Int) -&gt; RationalApproximant{T}</code></pre><p>Compute the type <code>(m, n)</code> CF approximant and then, if necessary, fine-tune the approximant to become a true minimax approximant using the <a href="https://en.wikipedia.org/wiki/Remez_algorithm">Remez algorithm</a>. If not specified, <code>dom</code> defaults to <code>(-1.0, 1.0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/blob/ada1293b8ef3328395fd40782a7f984f459dd4ac/src/CaratheodoryFejerApprox.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CaratheodoryFejerApprox.monocoeffs" href="#CaratheodoryFejerApprox.monocoeffs"><code>CaratheodoryFejerApprox.monocoeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">monocoeffs(res::RationalApproximant{T}; transplant = true) -&gt; NTuple{2, Vector{T}}
monocoeffs(res::RationalApproximant{T1}; ::Type{T2} = BigFloat, transplant = true) -&gt; NTuple{2, Vector{T1}}</code></pre><p>Extract polynomial coefficients of a <code>RationalApproximant</code> in the monomial basis.</p><p>Because converting to monomial coefficients can be numerically unstable, optionally pass a higher precision type to <code>monocoeffs</code> for intermediate computations.</p><p>When <code>transplant = true</code> (the default), the monomial coefficients correspond to the original function <code>f(x)</code> on the interval <code>dom</code>. When <code>transplant = false</code>, the coefficients correspond to the linearly transplanted function <code>g(t) = f((x - mid) / rad)</code> where <code>mid</code> and <code>rad</code> are the midpoint and radius of <code>dom</code> and <code>-1 &lt;= t &lt;= 1</code>.</p><p>Note that, particularly when <code>|mid|</code> is large, it can be much more numerically stable to evaluate the approximant via <code>evalpoly(t, p)</code> using the non-transplanted coefficients <code>p</code> and <code>t = (x - mid) / rad</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/blob/ada1293b8ef3328395fd40782a7f984f459dd4ac/src/CaratheodoryFejerApprox.jl#L95-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CaratheodoryFejerApprox.polynomialcf" href="#CaratheodoryFejerApprox.polynomialcf"><code>CaratheodoryFejerApprox.polynomialcf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polynomialcf(f, m::Int) -&gt; RationalApproximant{Float64}
polynomialcf(f, dom::NTuple{2, T}, m::Int) -&gt; RationalApproximant{T}</code></pre><p>Approximate a function <code>f</code> with a degree <code>m</code> polynomial CF approximant on the interval <code>dom</code>. If not specified, <code>dom</code> defaults to <code>(-1.0, 1.0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/blob/ada1293b8ef3328395fd40782a7f984f459dd4ac/src/CaratheodoryFejerApprox.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CaratheodoryFejerApprox.rationalcf" href="#CaratheodoryFejerApprox.rationalcf"><code>CaratheodoryFejerApprox.rationalcf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rationalcf(f, m::Int, n::Int) -&gt; RationalApproximant{Float64}
rationalcf(f, dom::NTuple{2, T}, m::Int, n::Int) -&gt; RationalApproximant{T}</code></pre><p>Approximate a function <code>f</code> with a type <code>(m, n)</code> rational CF approximant on the interval <code>dom</code>, where <code>m</code> is the numerator degree and <code>n</code> is the denominator degree. If not specified, <code>dom</code> defaults to <code>(-1.0, 1.0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/CaratheodoryFejerApprox.jl/blob/ada1293b8ef3328395fd40782a7f984f459dd4ac/src/CaratheodoryFejerApprox.jl#L77-L83">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 7 February 2024 00:36">Wednesday 7 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
